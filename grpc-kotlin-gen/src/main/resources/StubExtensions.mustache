{{#packageName}}
package {{packageName}}
{{/packageName}}

import io.rouz.grpc.*
import {{packageName}}.{{serviceName}}Grpc.{{serviceName}}Stub

import kotlinx.coroutines.channels.ReceiveChannel
import kotlin.coroutines.suspendCoroutine

import io.grpc.Metadata
import io.grpc.stub.MetadataUtils

/**
 * Kotlin extension functions for [{{packageName}}.{{serviceName}}Grpc.{{serviceName}}Stub]
 *
 * Generated by gRPC Kotlin generator
 * Source: {{protoName}}
 */

{{#methods}}
{{#javaDoc}}{{{javaDoc}}}{{/javaDoc}}
{{#deprecated}}@Deprecated("deprecated"){{/deprecated}}
{{^isManyInput}}
{{^isManyOutput}}
{{! == unary req, unary resp == }}
suspend inline fun {{serviceName}}Stub.{{methodName}}(request: {{inputType}}): {{outputType}} {
    return suspendCoroutine {
        {{methodName}}(request, ContinuationStreamObserver(it))
    }
}
{{/isManyOutput}}
{{#isManyOutput}}
{{! == unary req, streaming resp == }}
fun {{serviceName}}Stub.{{methodName}}(request: {{inputType}}): ReceiveChannel<{{outputType}}> {
    val responseChannel = StreamObserverChannel<{{outputType}}>()
    {{methodName}}(request, responseChannel)
    return responseChannel
}
{{/isManyOutput}}
{{/isManyInput}}
{{#isManyInput}}
{{^isManyOutput}}
{{! == streaming req, unary resp == }}
fun {{serviceName}}Stub.{{methodName}}(): ManyToOneCall<{{inputType}}, {{outputType}}> {
    val responseDeferred = StreamObserverDeferred<{{outputType}}>()
    val requestObserver = {{methodName}}(responseDeferred)
    return ManyToOneCall(requestObserver, responseDeferred)
}
{{/isManyOutput}}
{{#isManyOutput}}
{{! == streaming req, streaming resp == }}
fun {{serviceName}}Stub.{{methodName}}(): ManyToManyCall<{{inputType}}, {{outputType}}> {
    val responseChannel = StreamObserverChannel<{{outputType}}>()
    val requestObserver = {{methodName}}(responseChannel)
    return ManyToManyCall(requestObserver, responseChannel)
}
{{/isManyOutput}}
{{/isManyInput}}
{{/methods}}

/**
* Adds new binary header and returns the client
*/
fun {{serviceName}}Stub.addBinaryHeader(
header: String,
bytes: ByteArray
): {{serviceName}}Stub {
val headers = Metadata()
val key = Metadata.Key.of(header, Metadata.BINARY_BYTE_MARSHALLER)
headers.put(key, bytes)

return MetadataUtils.attachHeaders(this, headers)
}
